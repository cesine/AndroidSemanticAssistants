/*
 * Semantic Assistants -- http://www.semanticsoftware.info/semantic-assistants
 * 
 * This file is part of the Semantic Assistants architecture.
 * 
 * Copyright (C) 2012, 2013 Semantic Software Lab,
 * http://www.semanticsoftware.info
 * 
 * The Semantic Assistants architecture is free software: you can redistribute
 * and/or modify it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 */
package com.semanticassistants.client.portal.liferay;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import javax.xml.namespace.QName;
import javax.xml.ws.WebServiceException;

import org.apache.commons.collections.map.MultiValueMap;

import net.java.dev.jaxb.array.StringArray;

import com.google.gson.Gson;

import info.semanticsoftware.semassist.csal.ClientUtils;
import info.semanticsoftware.semassist.csal.result.AnnotationVector;
import info.semanticsoftware.semassist.csal.result.SemanticServiceResult;
import info.semanticsoftware.semassist.server.GateRuntimeParameter;
import info.semanticsoftware.semassist.server.GateRuntimeParameterArray;
import info.semanticsoftware.semassist.server.SemanticServiceBroker;
import info.semanticsoftware.semassist.server.SemanticServiceBrokerService;
import info.semanticsoftware.semassist.server.ServiceInfoForClient;
import info.semanticsoftware.semassist.server.ServiceInfoForClientArray;
import info.semanticsoftware.semassist.server.UriList;
import info.semanticsoftware.semassist.server.UserContext;

/**
 * The Semantic Assistants utility methods.
 * 
 * @author Bahar Sateli
 */
public class SemanticAssistantsUtils {
	/** The singleton object for this class. */
	public static SemanticAssistantsUtils instance = null;

	/** Semantic Service Broker Service static instance. */
	private static SemanticServiceBrokerService service = null;

	/** Semantic Service Broker static instance. */
	private static SemanticServiceBroker broker = null;

	/** Remembering the last host name used. */
	private static String lastHostname = null;

	/** Remembering the last port number used. */
	private static String lastPortnumber = null;
	
	/** The type of result generated by NLP pipelines (ANNOTATION, BOUNDLESS_ANNOTATION or FILE). */
	private static String resultType = "dummy";

	/** Protected constructor, since this is a utility class. */
	protected SemanticAssistantsUtils() {
		// defeat instantiation
	}

	/**
	 * Public constructor for the singleton object.
	 * 
	 * @return the singleton object for this class
	 */
	public static SemanticAssistantsUtils getInstance() {
		if(instance == null) instance = new SemanticAssistantsUtils();
		return instance;
	}

	/**
	 * Returns the broker agent for the specified Semantic Assistants server.
	 * 
	 * @param endpointURL
	 *            the URL of the sever in form of http://hostname:portnumber
	 * @return the broker object
	 */
	private static SemanticServiceBroker getBroker(final String endpointURL) {
		// if(broker == null){
		// if( service == null ){
		System.out.println("Creating broker using " + endpointURL);
		try {
			if(endpointURL.trim().length() != 0) {
				service =
					new SemanticServiceBrokerService(new URL("http://" + lastHostname + ":" + lastPortnumber + "/SemAssist?wsdl"), new QName(
						"http://server.semassist.semanticsoftware.info/", "SemanticServiceBrokerService"));
			} else {
				// FIXME: should look into a properties file
				System.out.println("Creating broker using default values");
				service = new SemanticServiceBrokerService();
			}
		} catch(MalformedURLException e) {
			System.out.println("Invalid endpoint URL: " + endpointURL);
			// e.printStackTrace();
		} catch(WebServiceException e1) {
			System.err.println("No server not found on " + endpointURL + ". Please check whether the server is online.");
			// e1.printStackTrace();
		}
		// }//service
		broker = service.getSemanticServiceBrokerPort();
		// }
		return broker;
	}

	/**
	 * Return the list of available assistants names.
	 * 
	 * @param endpointURL
	 *            the URL of the sever in form of http://hostname:portnumber
	 * @return list of available assistants names
	 */
	public synchronized String getAvailableServices(final String endpointURL) {
		StringBuffer output = new StringBuffer();
		if(isValidEndpoint(endpointURL)) {
			try {
				ServiceInfoForClientArray sia = getBroker(endpointURL).getAvailableServices();
				List<ServiceInfoForClient> serviceInfos = sia.getItem();
				Iterator<ServiceInfoForClient> it = serviceInfos.iterator();
				while(it.hasNext()) {
					ServiceInfoForClient info = it.next();
					Gson gson = new Gson();
					output.append(gson.toJson(info));
					output.append(",");
					// System.out.println(info.getServiceName());
					// output.add(new ServiceInstance(info.getServiceName(),
					// info.getServiceDescription()));
				}
			} catch(Exception e) {
				System.err.println("Can not read the list of available services.");
				e.printStackTrace();
			}
		} else {
			return null;
		}
		String results = output.toString();
		try {
			results = results.substring(0, results.lastIndexOf(","));
			results = "[" + results + "]";
			return results;
		} catch(Exception e) {
			System.out.println(e.getMessage());
		}
		return results;
	}

	public synchronized String invokeAssistant(final String endpointURL, final String serviceName, final String paramsQuery, final String contentString) {
		StringArray content = new StringArray();
		UriList list = new UriList();
		list.getUriList().add("#literal");
		content.getItem().add(contentString);
		Map<String, String> queryParamsList = new HashMap<String, String>();
		GateRuntimeParameterArray rtpArray = new GateRuntimeParameterArray();

		if(!paramsQuery.trim().equals("")){
			String[] tokens = paramsQuery.split("&");
			for(String token: tokens){
				String[] parts = token.split("=");
				String paramName = parts[0];
				String paramValue = parts[1];
				//System.out.println("Putting (" + paramName + "," + paramValue + ")");
				queryParamsList.put(paramName, paramValue);
			}
			
			ServiceInfoForClientArray services = getBroker(endpointURL).getAvailableServices();
			for(ServiceInfoForClient service : services.getItem()){
				// Find what are this service runtime parameters are
				if(service.getServiceName().equals(serviceName)){
					List<GateRuntimeParameter> params = service.getParams();
					// the order of service's runtime parameters are kept for presentation, thus it's safe to sequentially iterate
					for(Iterator<GateRuntimeParameter> itr = params.iterator(); itr.hasNext();){
						GateRuntimeParameter param = itr.next();
						String type = param.getType();
						try{
							if(queryParamsList.containsKey(param.getParamName())){
								if(type.equals("int")){
									param.setIntValue(Integer.parseInt(queryParamsList.get(param.getParamName())));
								}else if(type.equals("string")){
									param.setStringValue(queryParamsList.get(param.getParamName()));
								}else if(type.equals("double")){
									param.setDoubleValue(Double.parseDouble(queryParamsList.get(param.getParamName())));
								}else if(type.equals("boolean")){
									param.setBooleanValue(Boolean.parseBoolean(queryParamsList.get(param.getParamName())));
								}else if(type.equals("url")){
									param.setUrlValue(queryParamsList.get(param.getParamName()));
								}							
							}
						}catch(Exception e){
							System.out.println(e.getMessage());
						}
						rtpArray.getItem().add(param);
					}
					break;
				}
			}
		}

		String results = getBroker(endpointURL).invokeService(serviceName, list, content, 0L, rtpArray, new UserContext());
		return results;
	}

	/**
	 * Performs sanity check for the endpoint URL.
	 * 
	 * @param endpointURL
	 *            end point URL address
	 * @return true if it's a valid URL, false otherwise
	 */
	private boolean isValidEndpoint(String endpointURL) {
		try {
			String hostname = endpointURL.substring(endpointURL.indexOf("://") + 3, endpointURL.lastIndexOf(":"));
			String portnumberString = endpointURL.substring(endpointURL.lastIndexOf(":") + 1);
			// check if port number is valid
			Integer.parseInt(portnumberString);
			// remember the settings
			lastHostname = hostname;
			lastPortnumber = portnumberString;
		} catch(Exception e) {
			System.err.println("Bad URL address (" + endpointURL + "). Aborting the request...");
			return false;
		}
		return true;
	}

	public synchronized String XMLtoJSON(final String results) {
		Gson gson = new Gson();
		String json = "";
		Vector<SemanticServiceResult> resultObjects = ClientUtils.getServiceResults(results);
		MultiValueMap annotsMap = null;
		for(Iterator<SemanticServiceResult> it = resultObjects.iterator(); it.hasNext();) {
			SemanticServiceResult current = it.next();
			if(current.mResultType.equals(SemanticServiceResult.ANNOTATION)) {
				if(annotsMap == null) {
					annotsMap = new MultiValueMap();
				}
				/**
				 * List of annotations that maps document IDs to annotation
				 * instances
				 */
				HashMap<String, AnnotationVector> allAnnotations = current.mAnnotations;
				Set<String> documents = allAnnotations.keySet();
				for(Iterator<String> it2 = documents.iterator(); it2.hasNext();) {
					String documentID = it2.next();
					AnnotationVector vector = allAnnotations.get(documentID);
					json += gson.toJson(vector.mAnnotationVector) + ",";
					annotsMap.put(documentID, allAnnotations.get(documentID));					
				}
				resultType = SemanticServiceResult.ANNOTATION;
			}else if(current.mResultType.equals(SemanticServiceResult.BOUNDLESS_ANNOTATION)) {
				HashMap<String, AnnotationVector> allAnnotations = current.mAnnotations;
				Set<String> documents = allAnnotations.keySet();
				for(Iterator<String> it2 = documents.iterator(); it2.hasNext();) {
					String documentID = it2.next();
					AnnotationVector vector = allAnnotations.get(documentID);
					json += gson.toJson(vector.mAnnotationVector) + ",";
				}
				resultType = SemanticServiceResult.BOUNDLESS_ANNOTATION;
			}else if(current.mResultType.equals(SemanticServiceResult.FILE)){
				String fileURL = current.mFileUrl;
				String fileContent = broker.getResultFile(fileURL);
				resultType = SemanticServiceResult.FILE;
				return fileContent;
			}
		}
		try {
			json = json.substring(0, json.length() - 1);
			// FIXME: why are we creating yet another array?
			json = "[" + json + "]";
		} catch(IndexOutOfBoundsException e) {
			System.err.println("Invalid JSON string. Aborting...");
		}
		return json;
	}
	
	public String getResultType(){
		return resultType;
	}
}
